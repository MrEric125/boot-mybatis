内存模型，和线程模型

程序并发中的问题：
1. 缓存一致性问题导致可见性问题
2. 处理器优化导致原子性问题
3. 指令重排序导致有序性问题

参考： http://ifeve.com/java-memory-model-1/    

在谈到内存模型的时候，常常会牵扯到线程之间的通信，和线程之间数据的同步。 通行机制有一下两种     
### **并发编程模型分类：**
1. 共享内存模型：（java并发采用的内存模型）
    线程之间贡献程序的公共状态，线程之间通过写-读内存中的公共状态来隐式的进行通行
2. 消息传递并发模型：
    线程之间没有公共的状态，线程之间必须通过明确的发送消息来显示的进行通信

同步是指程序用于控制不同线程之间操作发生的相对顺序的机制

### **java内存模型**
****
**内存可见性问题**  

局部变量(Local Varialbes),方法定义参数(Formal method parameters) 和异常处理器参数（Exception Handler parameters） 不会在线程之间共享，不会出现内存可见性问题
实例域（堆内存中），静态域（方法区）中的数据会再线程之间共享，会出现内存可见性问题  
****
**内存模型（JMM）**     

java线程之间数据共享是通过java内存模型(JMM)控制的。JMM决定了一个线程对共享变量的写入核实对另一个线程可见，从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系         

线程之间的共享变量存储在主内存中（Main Memory）中，每个线程之间都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以以读写共享变量的副本。本地内存其实并不存在，它涵盖 了缓存、写缓冲区、寄存器以及其他的硬件编译器优化

线程之间的通行如图  
![线程通信](../../etc/jvm/xiancheng.png)
似乎上，我们已经解释了什么是JMM,但是我们忽略了一个问题，那就是重排序
****
**重排序**  

如果指令会重排序，那么我们如何写出满意的代码，

**happen-before**
happen-before八个原则