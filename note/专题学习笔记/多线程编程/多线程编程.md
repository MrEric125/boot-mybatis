# 多线程编程

**整理过程中出现的问题**

- [ ] 死锁与活锁问题出现的解决方案（Mysql,java）

### 基础知识



1. 进程、线程和任务

   进程（Process）是程序运行实例，是程序向操作系统申请资源(如内存空间和句柄文件)的基本单位

   线程是今晨各种可以独立执行的最小单位。例如一个从服务器上下载大文件的程序为了提高执行效率，可能会使用多个进程执行下载任务

   一个进程可以包含多个线程，同一个进程中的所有线程现共享该进程中的资源，如内存空间、文件句柄等，进程与线程之间的关系就好比是一个公司与员工之间的关系，

   线程索要完成的计算被称之为任务，特定线程总是在执行着特定的任务，任务代表线程索要完成的工作，一个任务可以是从服务器上下载一个文件，加压缩一批文件，解压缩一个文件，见识某些文件的修改时间等，

2. 使用多线程的原因

   1. 提高系统吞吐量
   2. 合理利用硬件资源
   3. 避免某个请求对其它请求造成不必要的影响
   4. 提高响应性，最小化对系统资源的使用

3. **可能会遇到的问题**

   1. 线程安全问题

   2. 线程活性问题，可能会产生活锁或者死锁问题，

      活锁：一个线程一直尝试狗哥操作但是无法进展。

      死锁：就是两个锁住的资源接下来分别去获取对方的资源

   3. 上下文切换



**线程属性**

![image-20200201222302500](C:\Users\Eric\AppData\Roaming\Typora\typora-user-images\image-20200201222302500.png)

按照线程是否会组织java虚拟机正常停止，我们可以将java中的线程分为守护线程（Daemon Thread）和用户线程（User Thread）也称之为非守护线程，

线程的daemon属性用于表示相应线程是否为守护线程，用户线程会阻止java虚拟机的正常停止，即一个java虚拟机只有在其所有用户线程都运行结束（Thread.run()调用未结束）的情况下才能正常停止。而守护线程则不会影响java虚拟机的正常停止，即应用程序中又守护线程在寻衅也不影响java虚拟机的正常停止

**线程层次关系**

假设线程A所执行的代码创建了线程B，那么，习惯上我们称线程B为线程A的子线程，相应的县春城A也就被称之为线程B的父线程，线程的这种关系被称之为线程的层次关系

在java平台中，一个线程是否是一个守护线程默认取决于其父线程，默认情况下父线程是守护线程成，子线程也是守护线程，父线程是用户线程，子线程也是用户线程。父线程在创建子线程后启动子线程之前可以调用该线程的setDaemon()方法，将相应的线程设置为守护线程或者用户线程，

一个线程的优先级默认值为该线程的父线程的优先级，即如果我们没有设置或者更改一个线程的优先级，那么这个线程的优先级的值与父线程的优先级相等，不过遗憾的是，javaAPI中并没有提供获取一个线程的父线程或者获取一个线程所有子线程，

习惯上，我们也称某些子线程工作者线程（Worker Thread）或者后台线程（Background Thread）。工作线程通常是其父线程创建来用于专门负责某项特定任务的执行的。

**线程的生命周期**

下图是线程各个状态之间相互转换的示意图

![线程状态转换](D:\workspace\IntelliJ Idea\source\boot-mybatis\note\etc\java\线程状态相互转换.png)

线程状态可以通过监控工具查看，也可以通过Thread.getState()调用来获取。对线程进行监视的主要途径是获取并查看程序的线程转储（Thread Dump）一个程序的线程转储包含了获取这个线程转储的那一刻该程序的线程信息，包含了具体的线程属性，生命周期状态，贤臣过的调用栈，以及锁等相关信息

线程监控工具有一下几种

1. jvisualvm
2. jstack
3. JMC
4. kill -3 PID

**串行、并发与并行**

串行(Sequential)：也就是彼此之间必须有个先后顺序的执行某些线程工作,对于系统资源而言，对于多个任务，单核从前往后一次处理

并发(Concurrent): 投入的也只是核，但是对于执行的多个任务，它是相互交替进行的，这种方式能够很好的提高系统的吞吐量，对于用户而言似乎是多个线程同时在运行，但是对于cpu，每个执行时，是只有一个线程在运行的，但是会有多个线程相互交替运行

并发(Parallel)d:这才是真正的利用了多核，它能够调用CPU的多核同时执行，

![image-20200202120708026](C:\Users\Eric\AppData\Roaming\Typora\typora-user-images\image-20200202120708026.png)

**竞态**

多线程编程中经常遇到的一个问题对于同样的输入，程序的输入有时候是正确的，有时候却是错误的，这种一个计算结果的正确性与实践有关的现象就被称之为竞态(Race condition)

**二维表分析法：解释竞态的结果**

状态变量(State Variable):即类的实例变量、竞态变量

共享变量(Shared variable): 即可以被多个线程共同访问的变量

竞态的两种模式：read-modify-write(读-改-写)、check-then-act(检测而后行动)

**线程安全**

一般而言，如果一个类在单线程环境下能够运行正常，并且在多线程环境下，在其适用房不必为其做任何改变的情况下也能够运行正常，那么我们就说这事线程安全的。当我们在使用一个类时，首先我们要关心这个类是否是线程安全的，因为这关系到我们如何正确使用这些类。

一个类如果不是线程安全的，我们就说这个类在多线程环境下直接使用存在线程安全问题，线程安全问题概括起来可以分为三个方面：原子性、可见性、有序性。这也和JVM内存模型相关

**原子性**

原子(Atomic)的字面意思是不可分割的(Indivisible)。对于设计共享变量访问的操作，若该操作从其执行线程以外的任意线程来看是不可分割的，那么该操作就是原子操作，相应的，我们也称这种操作具有原子性。那么不可分割就是指某个操作(读，写)要么全部结束，要么尚未发生。

1. 原子操作时针对访问共享变量的操作。也就是说仅仅涉及到局部变量访问的饿操作无所谓是否是原子操作
2. 原子操作时从该操作的执行线程以外的线程来描述的，也就是说它只有在多个线程环境下有意义

Java中有两种方式来实现原子性：

一种是使用锁（Lock）:锁既有排他性，也就它能够保证共享变量在任意时刻只能够被一个线程访问，这就排除了多个线程在同一时刻访问同一个共享变量而导致的干扰和冲突的可能。

另一种是利用处理器提供的专门CAS(Compare an Swap)指令，后面会专门介绍CAS,这里需要简单说明一下，CAS其实也是一种乐观锁

java中 long和double型以外的任何类型的变量的写操作都是原子操作，对于long 和double，java语言规范并不保证其具有原子性，尽管如此，java语言规范还特别规定了volatile关键字修饰的long/double变量写操作具有原子性。

java语言中针对任何变量的读操作都是原子性的

**可见性**
在多线程环境下，一个线程对某个共享变量进行更新之后，后续访问该变量的线程可能无法立即读取到这个更新之后的结果，甚至永远也无法读取到这个更新之后的结果，这就是线程安全问题的另一个表现形式，可见性（Visibility）

`具体可见性可以参考JVM内存模型`

**有序性**

有序性(Ordering)指在什么情况下一个处理器上运行的一个线程所执行的内存访问操作子另外一个处理器上运行的其他线程看来是乱序的，

1. 重排序：

   简单说就是编译器可能会改变两个操作的先后顺序，处理器可能不是完全按照程序的目标代码所指定的顺序执行指令，另外一个处理器上执行的多个操作，从其他处理器的角度来看其书序可能与目标代码所指定的顺序不一致，这种现象就叫做重排序

   在java平台中，静态编译器(javac)基本上不会执行指令重排序，而JIT编译器则可能执行指令重排序，

   重排序所具有的两个特征：

   1. 重排序可能导致线程安全问题
   2. 重排序不是必然出现

   **为什么需要对代码进行重排序？**

   ​		现代处理器为了提高指令执行效率，汪汪不是按照程序顺序逐一执行指令的，而是动态调整指令的顺序，做到那条指令就绪就先执行那条指令，这就是处理器的乱序执行，在乱序执行的处理器中，指令时一条一条按照程序顺序被处理器读取的（"顺序读取"），然后这些指令中，哪些就绪了，就先执行哪些指令，而不是完全按照程序顺序执行。这些指令执行的结果（要进行写寄存器或者写内存的操作）会被先存入重排序缓冲器（ROB）,而不是直接被写入执行器或者主内存中，重排序缓冲器会将各个指令的执行结果按照相应指令被处理器读取的顺序提交（commit,即写入）到寄存器或则内存中去（顺序提交），在乱序执行的情况下，尽管指令的执行顺序可能没有完全按照程序顺序，但是由于指令的执行结果的提交（反应到寄存器和内存中）任然是按照程序顺序来的，因此处理器的指令重排序并不会对单线程程序的正确性产生影响

   ​		处理器的乱序执行还采用了一种被称之为猜测执行（Speculation）的技术，猜测执行技术就是不确定哪条能够通往目的地，但是程序可以凭猜测走其中哪一条，大不了猜错了，掉头重新执行。

   **存储子系统的重排序**

   主内存（RAM）相对于处理器是一个慢速设备，为了避免其拖后腿，处理器并不是直接访问主内存的，而是通过高速缓存（Cache）访问主内存的，在此基础上，现代处理器还引入了写缓冲器（Store Buffer，也成Write Buffer）以提高写高速缓存操作（以实现写主内存）的效率，有的处理器对所有的写主内存的操作都是通过写缓冲器进行的，

#### 同步机制

#### 线程之间的协作

#### 线程管理

#### JVM内存模型与多线程编程相关

#### 多线程编程的性能校对

### JUC 介绍

![juc大纲图](D:\workspace\IntelliJ Idea\source\boot-mybatis\note\etc\java\juc\juc-total-full.png)

#### juc工具类

#### cas

#### atomic类

#### aqs

##### aqs对锁的应用

### 多线程设计模式

多线程设计模式这一块主要参考了《java多线程编程实战设计模式篇》



#### 不可变对象(Immutable Object)

如果存在多个线程并发的修改某个对象的状态或者一个线程访问该对象的状态而另外一个线程视图修改该对象的状态，我们不得不做一些同步访问控制保证数据的一致性，而这些同步访问他控制，如显示锁和CAS操作，都会带来一些额外的性能开销问题，这个时候不可变对象就能够很好的解决这个尴尬局面

所谓不可变对象就是一经创建，，其对外可见的状态就保持不变，例如String、Integer。

一个严格意义上的不可变对象要满足一下所有条件

1. 类本身使用final修饰，防止其子类改变其定义的行为
2. 所有的字段都必须是final修饰的：这样不仅保证了语义上的不可变，更重要的是在多线程环境下由JMM保证了被修饰字段所引用对象的初始化安全，即final修饰的字段在其他线程可见时，它必须是初始化完成了的
3. 在对象的创建过程中，this关键字没哟泄露给其他类，防止其他类在对象的创建过程中修改其
4. 任何字段，若其应用了其它状态可变的对象，则这些字段必须是private修饰的，并且这些字段值不能对外暴露，如果有方法要返回这些字段值，字段必须要有防御性复制（Defensive Copy）

**Immutable Object 使用场景**

1. 被建模对象的状态变化不频繁，
2. 同事对一组相关的数据进行写操作，因此需要保证原子性
3. 使用某个duixian个作为安全的HashMap的Key

**Immutable Object使用需要注意的事项**

1. 被建模对象的状态变化比较频繁

   这种情况下也不是不可以使用不可变对象模式，只是这样的话就会增加[JVM垃圾回收]()的负担和CPU的消耗，我们需要总和考虑，

2. 使用等效或者近似的不可变对象

   有时候创建严格意义的不可变对象比较麻烦，但是我们可以无限想严格的不可变对象靠拢，这样有利于发挥不可变对象的好处

3. 防御性复制

Immutable Object在java库中的引用，CopyOnWriteArrayList,等等



#### 保护性暂挂(Guarded Suspension)

该设计模式的核心思想是如果某个线程执行特定的操作前需要满足一定的条件，则在该条件未满足时将该线程暂停运行(暂挂线程，使其处于等待（WAITING）状态，知道该条件满足时才继续该线程的运行)

**保护性暂挂的架构**
Guarded suspension 的核心是一个受保护的方法（Guarded method），该方法执行其索要真正的操作时需要满足特定的条件（predicate,即保护条件）当该条件不满足时，执行受保护方法的线程就会被挂起进入等待（Waiting）状态，知道该条件满足时该线程才会继续运行，此时，受保护方法才会整整执行其索要执行的操作。

#### 两阶段终止(Two-phase Termination)
#### 承诺(promise)
#### 生产者消费者(producer-consumer)
#### 主动对象模式(Active Object)
#### 线程池模式(Thread pool)
#### 线程特有存储(Thread Specific Storage)
#### 串行线程封闭(Serial Thread Confinement)
#### 主从模式(Master-Slave)主从模式、
#### 流水线(Pipeline)
#### 半同步半异步(Half-sync/Half-async)

### 分布式项目中多线程编程的思考



参考文献：

1. 《java多线程编程实战指南-核心篇》
2. 《java多线程编程实战指南-设计模式篇》