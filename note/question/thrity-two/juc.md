这节课我们学习Java的多线程和并发，
这节课重点知识有四个
线程的状态转换，线程的同步与互斥，线程池的运作机制详解，还有这个UC中常用的工具类，这四点后面会展开讲解，
现在看基础知识点，多线程协作时，因为对资源的锁定与等待会产生死锁。这里需要了解产生死锁的四个基本条件，要明白竞争条件，雨林街区()的概念，知道通过破坏造成死锁的四个条件来防止死锁。前面我们讲过进程间的通信方式，这里还有知道线程的通信方式，通信主要指线程之间的协作机制，例如wait notify。这部分你还需要知道Java多线程提供的一些机制，例如Threadlocal用来保存线程独享的数据交换机制，FockJoin用于大任务的分割与汇总，volatile对多线程数据可见性的保障以及线程的中断机制，其他还有AI的logo()的实现机制作交换的工作，窃取算法等内容，线程是JVM执行任务的最小单元，理解线程的状态转换是理解后续多线程问题的基础。
第一个详解知识点介绍，线程状态转换。在JVM运行中，线程一共有new block。Waiting timed waiting terminated6种状态，这些状态对应Thread中state枚举类的状态。乳头上方()创建一个线程的时候，线程处在new状态，运行Thread start()方法后，线程进入Runnable运行状态，这个时候所有可运行状态的线程并不能马上运行，而是需要先进入就绪状态，等待线程调度就是图中间的ready状态。才能进入运行状态，就是图中的running运行状态，可随着不同条件转换成纯Niu()以外的其他状态，我们先看左边再运行太重()的线程，进入signal从不块儿()，或者通过方法时，如果获取锁失败，就会进入到block的状态。等获取到损失，会从block状态恢复到就绪状态。再来看右边运行中的线程，还会进入等待状态。这两个等待状态，一个是有超时时间的等待，例如调用object的wait方法，Write类的join方法等。另外一个是无超时的等待

Sight累得Zheng方法或者lock support的park方法，这两种等待都可以通过note或者mpeg结束等待状态恢复到就绪状态，最后是线程运行完成结束时，如图下方线程状态就变成了terminated，第二个详解知识点是线程的同步互斥，解决线程同步有互斥的主要方式是CS lock。我们先来看CSCS是属于一种乐观锁的，实现是一种轻量级锁，只有四种，很多工具类的实现就是基于CSCS操作的流程，如左图所示，线程在读取数据时不进行加速准备，协会出去时比较原值是否修改，若未被其他线程修改，则血回若已被修改的重新执行读取流程，这是一种乐观策略，认为并发操作并不总会发生。比较并且回的操作，通过操作系统的原语实现的，保证执行过程中不会被中断，CAS容易出现ABA问题，比如按右图所示的时序，线程提议在读取完值A后发生过两次显著仙游，线程T2写会了B，又由现成T3写回了A，此时的再写回时进行比较，发现值还是A，无法判断是否发生过修改，ABA问题不一定会影响结果，但还是需要防范，解决的办法可以增加额外的标志位或者时间戳，JUC工具包中提供了这样的类，`synchronized`是最常用的线程同步手段之一，它是如何保证同一时刻只有一个线程可以进入到临界区呢?我们`synchronized`是对对象进行加锁的，JJM中对象在内存中分为三块区域，对象头，实例数据和对齐填充，在对象头中保存了锁标志位和指向monitor对象的起始地址

上厕所是右边的就是一个对象，它对应的monitor对象的monitor被某个线程占用后就会处于锁定状态，如图中的owner部分会指向持有MT的对象的线程，另外monitor还有两个队列用来存放，进入以及等待获取锁的线程。synchronized应用的方法上是在自己买钟，是通过方法的ACC nice的标志来实现的，synchronized的用在同步矿石，在字节码中是通过monitor entrty和monitor exit来实现，针对Internet获取锁的方式，GM使用了所升级的优化方式就是先使用偏向所优先，同一线程再次获取所如果失败就升级为CS轻量级锁，如果再失败会进行短暂的自旋，防止线程被系统挂起，最后如果以上都失败，就会升级为重量级所在，介绍lock前我们先来看一下ABS，也就是队列同步器，这是实现lock的基础。左图就是ABS的结构图，从图中可以看出，HS有个state标志为值，为一时表示有线程占用，其他线程需要进入到同步队列，等待同步队列是一个双向链表。等获得锁的线程需要等待某个条件时，会进入肯定Shun的等待队列，等待队列可以有多个，但肯定是条件满足时，线程会从等待队列重新进入到同步队列进行获取所得竞争，瑞安趁着lock就是基于S实现的，我们看右边的图与安全的lock内部有公平所和非功利所两种实现，差别就在于新来的线程，有没有可能比已经在同步队列中等待的线程更早获得所。合理安全的lock的实现方式类似sample也是基于S，差别在于与安全的lock，独占锁，共享锁第三个知识点介绍，线程池线程池，通过复用线程，避免线程频繁的创建与销毁，Java的X code，工具类提供了五种类型，线程池的创建方法，就是我在PPT中列出的这五种，我们看看他们的特点和适用场景，第一个是固定大小线程池，特点是线程数固定，使用的是无界缓冲队列，适用于任务数量不均匀的场景，以及对内存压力不敏感但对系统复杂，比较敏感的场景。第二个是CAD的线程池，特点是不限制创建的线程数，适用于要求低颜值的短期任务的场景。第三个是单线程线程池，也就是一个现成的固定线程池，适用于需要异步执行，但需要保证任务执行顺序的场景，第四个是scheduled线程池，适用于定期执行任务的场景支持，按固定的频率定期执行和按固定的岩石定期执行两种方式，第五个是工作窃取，线程池使用，Fo将铺是固定并行度的多任务队列，适合任务执行市场不均匀的场景，前面提到的线程池除了工作，窃取线程之外，都是通过stride和SQL的不同初始化参数来创建的。构造函数的参数列表，看到这张图，第一个参数设置核心线程数，默认情况下和新线程会一直存活。第二个参数设置最大线程数决定线程池最多可以创建多少线程。第三个参数和第四个参数用来设置现成的空闲时间和空闲时间的单位，到线程闲置超过空闲时间时就会被销毁，可以通过lacoste帽子方法来允许核心线程被回收。第五个参数设置缓冲队列，图中左下方的三个队列是设置线程池时最常使用的，换成队列，其中一个有界队列就是指队列有最大容量限制。Link的block EQ是无界，队列就是队列，不限制容量，最后一个是新款的SQL，是一个同步队列，内部没有缓冲区。第二个参数设置线程池工厂方法。线程工厂用来创建新的线程，可以用来对现成的一些属性进行定制，例如现成的group线程，明儿优先级等，一般使用默认工厂类即可。第七个参数设置线程池满足的拒绝策略。如右下角所示，有四种策略about策略在线，程池满后提交新任务时，会抛出rejected execution exception。这个也是默认的拒绝策略，Discard策略会在提交失败时对任务直接进行丢弃。可能院子策略会在提交失败时有提交任务的线程直接执行提交的任务discard oldest策略会丢弃最早提交的任务，我们再来看前面说的几种线程池都是使用怎样的参数来创建。

因何最大线程数都设置成指定的线程数，这样线程池中就只会使用固定大小的线程书。对于使用的是无界队列，Link blocking queue。single线程池就是线程数设置唯一的固定线程池的线程池它的核心线程数设置为零最大线程数

设置唯一的顾虑线程池的线程池，它的核心线程数设置为零，最大线程数是整数，Int的最大值主要是通过把缓存队列设置成SQLSQL，这样只要没有空闲的线程就会新建scheduled线程池，与前几种不同的是使用了delete u q，这是一种爱延迟时间获取任务的优先级队列，我们相信诚实提交任务时可以使用XP

区别就是可以返回一个对象，通过future对象可以了解任务的执行情况，可以取消任务的执行，还可以获取执行结果或者执行异常，三分meat最终也是通过execute执行的，我们看看图中线程池提交任务时的执行顺序。小线程只提交任务时，会首先判断线程池中的线程数是否大于设置的核心线程，如果不大于就创建一个核心线程来执行任务，如果大于核心线程数，就会判断缓存队列是否满了，如果美满的放入队列，等待线程空闲时来执行，如果队列已经满了，就判断是否达到了线程值设置的最大线程数，如果没达到就创建新的线程来执行任务，如果已经达到了最大线程数，就会执行指定的拒绝策略，这里需要注意队列的判断与最大线程数的判断，他们之间的顺序不要搞反。前面基础知识部分已经提到过JC是Java提供的用于多线程处理的工具，类库我们来看看其中常用工具类的作用，看PPT表格，第一行的累都是基本数据类型的原子类，包括atomic不离。合同给Lang是通过ac线的，基于CS是底层工具类，只有C中很多类的底层都使用到了F包装的功能，Safely提供了类似C的指针操作，提供CS的功能，按C类中的所有方法都是native修饰的，另外的狼，Idle等四个类是JDK1.8中提供了更高效的操作累，让idle基于cell实现使用，分段所思想是一种以空间换时间的策略，更适合高并发场景。Lac u later提供了别来得更强大的功能，能够指定对数据的操作规则，例如可以把对数据的相加操作改成相乘操作，第二，行中的类提供了对对象的原子读写功能后，两个妹儿，Thomas champ的reference和tommy markel reference是用来解决我们前面提到的aba问题，分别基于时间戳和标记未来，解决毕业表格中一行的累，主要是所相关的类，例如我们前面介绍过的瑞安重入锁与安全的lock的独占所不同，三，Ofo共享所允许多个线程共享资源，适用于限制使用共享资源线程数量的场景，比如一百个车辆要使用20个停车位，那么醉

这允许20个车占用停车位。是damn

资源线程数量的场景，例如一百个车辆要使用20个停车位，那么最多允许20个车占用停车位。Stamp的log是一点儿八中改进的读写锁，是一种使用CH的乐观锁，能够有效防止血饥饿，所谓写饥饿，就是在多线程读写十读线程访问非常频繁，导致总是有毒线程占用资源，线程很难加上解锁。第二，行中主要是异步执行相关的，那这里可以重点了解JDK1.8中提供的complete double future可以支持流式调用，可以方便地进行多feature的组合使用，例如可以同时执行两个异步任务，然后对执行结果集合并处理，还可以很方便地设置完成时间。另外一个是一点儿七中提供的方法将铺采用分治思想将大任务分解成多个小任务来处理然后再合并处理结果的特点是使用工作计算法可以有效平衡任务

可以有效平衡任务，执行时间长短不一的场景，这一页表格中第一行是常用的阻塞队列，刚才讲解线程指使已经简单介绍过了这里再补充一点。Link的block EQ双端队列，也就是可以分别从队头和队尾操作入队出队。E re blocking queue战队点只能从对外入队，从队头槌。第二行是控制多线程协作使使用的类，其中count down lite实现计数器功能，可以用来等待多个线程执行任务后进行汇总，Safe barrier可以让一组线程等待着某个状态后再全部同时执行，一般在测试使用，可以让多线程更好的并发执行。Sample前面已经介绍过用来控制对共享资源的并发访问度。最后一行是比较常用的两个集合类，康康哈希map，前面的课程我们已经详细介绍过了，这里可以再了解一下，Copy write a list c lw通过写入数据时进行CT修改，然后再更新引用的方式来消除并行读写中的所使用。比较适合读多写少，数据量比较小，但是并发非常高的场景，讲解完本科的知识点，我们现在来看一下，面试考察点。第一个是要理解线程的同步与互斥的原理包括邻近资源

考察点，第一个是要理解线程的同步与互斥的原理，包括邻近资源临界区的概念，知道重量级锁轻量级锁，自旋锁偏向锁重入锁读写锁的概念。第二点，要掌握线程安全的相关机制，例如CS，辛苦，Nice的lock3种同步方式的实现原理，要明白，Thread local是每个线程独享的，局部变量，了解thread local，使用弱引用的摔的logo map，保存不同的thread local变量等等。第三点，要了解josie中的工具类的使用场景与主要的几种工具类的实现原理，例如。远程的log content还是map Lang en der等实现方式。第四点，要熟悉线程池的原理，使用场景常用配置，例如大量短期的任务的场景，适合使用CAD的线程池系统，资源比较紧张时，可以选择固定线程池。另外，注意慎用无界队列可能会有M的风险。第五点，要深刻理解线程的同步与异步阻塞与非阻塞。同步与异步的区别是，任务是否是在同一个线程中执行的。阻塞与非阻塞的区别是异步执行任务时线程是不是会阻塞等待结果

上面这些内容如果能做到这几点加分项，一定会给面试官留下更好的印象。第一点是可以结合实际项目经验或者实际案例介绍原理，例如。介绍线程值设置时，可以提到自己的项目中，有一个需要高吞吐量的场景，使用了cat的限制。第二点，如果有解决过多线程问题的经验或者排查思路的话，会获得面试的加分。第三点，能够熟悉常用的线程分析工具与方法，例如会使用j stack分析线程的运行状态，查找所对象的只有状况等等。第四点，了解Java对josie工具类做了哪些增强，例如提供了狼爱的来替换atomic long，更适合并发度比较高的场景。可以了解一下比active编程思想了解被压的概念与应用场景，最后我们来看一下相关的面试真题，前面讲解过的知识我就不再重复了，这里对重点题目提供一些思路。第一题，如何实现一个生产者与消费者模型可以尝试通过锁信号，量线程通信，阻塞队列等不同方式来实现。第四题，Wait与sleep有什么不同，回答要有4.1是waite属于object类，Sleep属于thread类。第二个是wait，会释放对象锁，Sleep不会，第三个是出现的位置，为他需要再同步块中使用，Sleep可以在任何地方使用，最后一点是sleep，需要捕获异常而为，他不需要。第六题，读写锁适用于什么场景可以回答，读写锁比较适合读并发，多写并发表的场景，另外一个解决这种场景的方法是copy write，第七题，线程之间如何通信，主要可以介绍一下，为此notify机制共享变量的thinker nice或者lock同步机制。第八题保证线程安全的方法有哪些可以提到cs性格nice的lock以及thread local等机制第九题如何尽可能提高多线程并发性能可以从尽量减少林区范围使用thread local减少新闻切换使用度