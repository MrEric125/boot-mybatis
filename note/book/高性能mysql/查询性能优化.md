

<!-- TOC -->

- [查询性能优化](#查询性能优化)
    - [慢查询的基础](#慢查询的基础)
        - [是否想数据库请求了不需要的数据](#是否想数据库请求了不需要的数据)
        - [MYSQL 是否在扫面额外的记录](#mysql-是否在扫面额外的记录)
    - [重构查询的方式](#重构查询的方式)
    - [查询执行的基础](#查询执行的基础)
        - [MYSQL客户端/服务器同性协议](#MYSQL客户端/服务器同性协议)
        - [查询缓存](#查询缓存)
        - [查询优化处理](#查询优化处理)
        - [查询执行引擎](#查询执行引擎)
        - [返回结果给客户端](#返回结果给客户端)
    

<!-- /TOC -->


# 查询性能优化
## 慢查询的基础
### 是否想数据库请求了不需要的数据
有些查询会请求超过实际需要的数据，然后这些多余的数据会被应用程序丢弃，这会给MySql服务器带来额外的负担，并增加网络开销，另外也会消耗应用服务器的CPU和内存资源
- 查询不需要的数据（没有带分页，把所有的数据查询出来，然后只取出自己想要的前几条）
- 多表关联的时候返回全部列
- 总是取出全部列 （`select * from` ）
- 多次查询相同的数据

### MYSQL 是否在扫面额外的记录
在确定查询只返回需要的数据以后，接下来就应该看看查询为了返回这些结果是否扫描了过多的数据，最简单的衡量查询开销的三个指标
- 响应时间
- 扫描的行数
- 返回的行数

 **响应时间**

 由两部分组成：服务时间和排毒时间。服务时间是指处理这个查询真正话费的时间，排队时间是指服务器因为等待某些资源而没有真正执行查询的时间，可能是在等待I/O操作，也可能是在等待行锁等等，当然实际情况可能会更复杂，响应时间并没有一致的规律或者公式。诸如存储引擎的锁（表锁、行锁）、高并发资源竞争、硬件响应等著作因素都会影响响应时间

 **扫描的行数和访问类型**

在平谷查询开销的时候，需要考虑一下从表中找到某一行数据的成本，在`EXPLAIN` 语句中的type列反应了访问类型，访问类型有很多，比如：全表扫描，索引扫描，范围扫描，唯一索引扫描，常数引用等等

例如查询SQL
```sql
 EXPLAIN SELECT * FROM `city` WHERE country_id=87
 ```
结果如图

![查询性能优化](../img/访问类型.png)
 我们可以看到 这个select 这个sql 将返回5行数据 索引名为`idx_fk_country_id` type为ref 那如果我们不查索引值而是查其他字段的话，会看到type为all(全表扫描) 预估需要查询数据的条数也更多 当然可能消耗的时间就会更多

## 重构查询的方式
 
  **一个复杂查询还是多个简单查询**

  **分而治之**
有时候对于一个大的查询我们需要分而治之，将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分数据

删除旧数据就是一个很好的例子，定期清除大量数据时，如果用一个大的语句一次性完成的话，则可能需要一次性锁住很多数据，占满整个事务日志，耗尽系统资源，阻塞很多小的，但是很重要的查询，所以将一个大的DELETE语句接分成多个较小的delete可以尽可能晓得影响MYSQL性能，批量插入也是一样

  **分解关联查询**

  先来看一个SQL
  ```sql
  select * from tag 
  join tag_post on tag_post.tag_id=tag.id
  join post on tag_post.post_id=post.id
  where tag.tag='mysql'
  ```
和这样一个SQL
```sql
  select * from tag  where tag.tag='mysql'
  select * from tag_post where tag_id=1234
  select * from post where post.id in (123,456,789)
```
初看之下这样做并没有什么好处，原本一条SQL现在被拆分成多条，返回的结果还是一样的，事实上用分解关联的方式重构查询有这样几个好处
- 让魂村的效率更高
- 执行单挑sql可以减少锁的竞争
- 查询本生效率也可能是会有提升
- 减少冗余记录的查询
 
（文章来源于高性能mysql 第三版，但其实对于以上的例子本人其实不是特别认同，如果一条关联查询被拆分成多个单表查询无形中是增加了数据连接请求的数量的）

## 查询执行的基础

当希望MYsql能够更高性能的执行查询时，最好的办法就是搞清楚MYSQL是如何优化和执行查询的，一旦理解了这一点，很多查询优化工作实际上就是遵循一些原则让优化器能够按照预想的合理方式运行
我们来看看MYsql 在执行一个查询的郭晨规划总到底做了什么

![查询性能优化](../img/查询执行路径.png)

1. 客户端发送一条查询给服务器
2. 服务器先检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。否则进入下一阶段
3. 服务器端进行SQL 解析、预处理、再由优化器生成对应的执行计划
4. MYSQL根据优化器生成的执行计划，调用存储引擎的API来执行查询
5. 将结果返回给客户端

### MYSQL客户端/服务器同性协议
当然一般情况下，我们不需要知道MYSQL通信协议的内部细节，但是理解其工作原理却是应该的。
> 在任何时刻，要么由服务器向客户端发送数据，要么由客户端向服务器发送数据，这两个动作不能够同事发生，所以我们无法也无需将一个消息切分成小块独立来发送。这也就意味着，没有办法进行`流量控制`一旦一段开始发送消息，另一端要接受完整个消息才能响应它

一般客户端用一个单独的数据包将查询传给服务器。如果查询语句很长的时候，超过了参数`max_allowed_packet`的值，就会抛出响应的异常
服务器响应给客户端的数据通常很多，由多个数据包组成，当服务器开始响应时，客户端必须完整的接收整个返回结果，不能够只接收一半的数据然后断开
 
 **查询状态**

 对于MYSQL的连接线程任何时刻都有一个状态，该状态表示MYSQL在当前正在做什么，，查看当前状态最简单的方式就是使用`show full processlist` (command 列就是状态)命令在一个查询的生命周期中，状态会变化很多次
 - Sleep： 线程正在等待客户端发送新的请求
 - Query： 线程正在执行查询或者赈灾将结果发送给客户端
 - Locked： 正在等待表锁
 - Analyzing and statistics 线程正在收集存储引擎的统计结果
 - Coping to tmp table [on disk] 线程正在执行查询，并且将其结果集都复制到一个临时表中。这种状态一般是要么是在做Group by 操作要么是文件排序或者是UNION操作
 - sorting result 线程正在对结果进行排序
 - sending data 线程可能在多个状态之间传送数据，或者在生成结果集或者在向客户端返回数据

### 查询缓存
在解析一个查询语句之前，如果查询缓存是打开的，那么MYSQL会有限检查这个查询是否命中查询缓存中的数据，查询和缓存中的查询即使只有一个字节不同那么不算匹配缓存结果，就会进入下一环节，如果当前查询恰好命中缓存，那么在返回结果之前，MYSQL会检查一次用户权限，，如果没问题那么久返回结果给可会端
### 查询优化处理
这个阶段包括一下几个部分：解析SQL、预处理、优化SQL执行计划，这个过程中任何错误，都可能种植查询，
**语法解析器和预处理**

MYSQL通过关键字将SQL语句解析并生成一颗对应的“解析树”。MYSQL解析器将使用MYSQL语法规则进行验证和解析查询，或者它会验证官架子是否错误或者使用关键字使用顺序是否正确，或者引号是否前后匹配等等。
预处理器则根据MYSQL规则进一步检查解析树是否合法，例如检查数据表和数据列是否存在，还有表名和别名，看看是否有歧义。然后预处理器还会检查权限
**查询优化器**
如果语法树是合法的，那么优化器就会将其转化成执行计划。一条查询可以有很多种执行方式，最后都会返回相同的结果，优化器的作用即使找到其中最好的执行计划。当然也有一些情况导致MYSQL优化器选择错误的执行计划
- 统计信息不准确
- 执行计划中的成本估算不等于时机执行的成本
- mySQL中的最优可能和你想的最优不一样。你可能希望执行时间尽可能短，但是MYSQL只是基于其成本模型选择最优的执行计划，而有些时候这并不是最快的执行方式
- MYSQL从不靠路并发执行的查询，这个可能影响当前查询的速度
- MYSQL也并不是任何时候都是基于成本的优化，有时候也会基于一些固定的规则，例如如果存在全文检索的MATCH()字句，则在存在全文索引的时候就使用全文索引，即使有时候使用别的索引和WHERE字句比这种方式块，MYSQL依然使用对应的全文索引
- MYSQL 不会考虑不受其控制的操作成本，例如执行存储过程或者用户自定义的函数的成本

优化器使用了很多优化策略，一种是静态优化，一种是动态优化，静态优化可以直接对解析树进行分析并完成优化，静态优化不依赖特别的数值，例如WHERE字句中带入的一些常数，静态优化在第一次完成后就一直有效。
相反动态优化这查询的上下文有关，也可能和很多其他的因素有关，如：WHERE条件中的取值、索引条目中对饮的数据行数，这需要在每次查询的时候都重新评估。

以下是MYSQL能够处理的优化类型
- 重新定义关联表的顺序
- 将外连接转化为内连接
- 使用等价变化规则
- 优化count(),MIN()和MAX()
- 预估并转化为常数表达式
- 覆盖索引扫描
- 子查询优化
- 提前终止查询
- 等值传播
- 列表in() 比较

**数据和索引的统计信息**

MYSQL查询优化器在生成查询的执行计划时，需要向存储引擎获取存储引擎存储的相应统计信息，包括：每个表或者索引有多少个页面，每个表的每个索引的技术是多少，数据行和索引长度，索引的分布信息等。优化器根据这些星系来选择一个最优的执行计划

**MYSQL如何执行关联查询**

MYSQL对任何关联都执行嵌套循环关联操作，即当MYSQL现在一个表中循环取出单条数据，然后再嵌套勋魂到下一个表中寻找匹配的行，一次下去直到倒找匹配的行为止，然后根据匹配的航返回查询中需要的各个列。MYSQL会尝试在最后一个关联表中找到所有匹配的行，如果最后一个关联表无法找到更多的行以后，MYSQL返回倒上一层次关联表，看是否能够找到更多匹配记录，一次迭代下去，

**执行计划**

MYSQL并不会生成查询字节码来执行查询，它会生成查询的一颗指令树，然后通过存储引擎执行完这个指令书并返回结果，最终的执行计划包含了重构查询的全部信息，任何夺标查询都可以使用一棵树来表示
![查询性能优化](../img/执行计划.png)

**关联查询优化器**

这是MYSQL最重要的一部分，它决定了多个表关联的顺序。它通过评估不同顺序时的成本来选择一个代价最小的关联顺序
下面这样一个关联查询可以通过不同的顺序来得到相同的结果（这里有一个例子阐述的很清楚， 篇幅问题不贴出来，复习时候记得看书）
关联优化器会尝试在所有的关联顺序中选择一个成本最小的来生成执行计划树，如果可能优化器会遍历每一个表然后逐个做嵌套循环计算每一颗可能的执行计划树的成本，最后返回一个最优的执行计划
`当然有时候查询的顺序是不能随意安排的`，这时关联优化器可以更具这些规则大大减少搜索空间。例如做链接、相关子查询、这是因为后面的表的查询需要依赖前面表的查询结果，这种依赖关系通常可以帮助优化器大大减少要扫描的执行计划数量，

**排序优化**

无论如何排序，都是一个成本很高的操作。所以从性能角度考虑，应尽可能避免排序，或者尽可能避免对大量数据进行排序。MYSQL有如下两种排序算法。
- 两次传输排序。
- 单次传输排序。

MYSQL在进行文件排序的时候，需要使用的临时空间可能会比想象的要大很多。原因在于MYSQL在排序时，对每一个排序记录都会分配一个足够长的定长空间来存放。这个定长空间必须足够长，以容纳其中最长的字符串。

在关联查询的时候，如果需要排序，MYSQL会分两种情况来处理这样的文件排序。如果order by子句中的所有列都来自关联的第一个表，那么MYSQL在关联处理第一个表的时候就进行文件排序。除此之外的所有情况，MYSQL都会现将关联的结果存放到一个临时表中。然后在所有的关联都结束后再进行文件排序，如果查询中有Limit的话,Limit也会在排序之后应用。所以，即使需要返回较少的数据，临时表表和需要排序的数量仍然会非常大，


### 查询执行引擎

在这个阶段MYSQL只是简单的根据这些计划给出的指令逐步执行。这个过程中有大量的操作，需要通过调用存储引擎实现的接口来完成。存储引擎接口有着非常丰富的功能。但是底层接口却只有十个。这些接口能够完成大部分的操作。例如，有一个查询某个索引的第一行的接口，再有一个查询某个索引下一条目的功能，有了这两个功能，我们就可以完成全索引扫描操作了

### 返回结果给客户端

如果查询可以被缓存，那么在这个阶段，MYSQL也会将结果放在查询缓存中，MYSQL 将结果集返回客户端是一个增量，逐步返回的过程，这样处理有两个好处，服务器端无需存储太多的结果，也就不会因为要返回太多结果而消耗太多内存。
结果集中的每一行都会以一个manzuMYSQL客户端/服务器同性协议的封包发送，再通过TCP协议进行传输，在TCP传输的过程中可能对MYSQL的封包也进行了缓存然后批量传输



