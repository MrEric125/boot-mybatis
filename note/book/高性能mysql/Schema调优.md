<!-- TOC -->

- [1. Schema与数据类型优化](#1-schema与数据类型优化)
    - [1.1. 选择优化的数据类型](#11-选择优化的数据类型)
        - [1.1.1. 整数类型](#111-整数类型)
        - [1.1.2. 实数类型](#112-实数类型)
        - [1.1.3. 字符串类型](#113-字符串类型)
        - [1.1.4. BLOB和TEXT类型](#114-blob和text类型)
        - [1.1.5. 使用枚举代替字符串类型](#115-使用枚举代替字符串类型)
        - [1.1.6. 日期和时间类型](#116-日期和时间类型)
        - [1.1.7. 位数据类型](#117-位数据类型)
        - [1.1.8. 选择标识符](#118-选择标识符)
        - [1.1.9. 特殊类型数据](#119-特殊类型数据)
    - [1.2. MYSQL schema 设计中的陷阱](#12-mysql-schema-设计中的陷阱)
    - [1.3. 范式和反范式](#13-范式和反范式)
    - [1.4. 缓存表和汇总表](#14-缓存表和汇总表)
        - [1.4.1. 物化视图](#141-物化视图)
        - [1.4.2. 计数器表](#142-计数器表)
    - [1.5. 加快ALTER Table  操作的速度](#15-加快alter-table--操作的速度)
        - [1.5.1. 只修改 .frm 文件](#151-只修改-frm-文件)
        - [1.5.2. 加快创建MYISAM索引](#152-加快创建myisam索引)
    - [1.6. 总结](#16-总结)

<!-- /TOC -->
# 1. Schema与数据类型优化
> 这里关注的是MYSQL数据库的设计主要介绍的也是MYSLQ和其它关系型数据库管理系统的一些区别
## 1.1. 选择优化的数据类型
MYSQL中的数据类型有很多，这里有几个我们选择数据类型的基本原则
- 更小通常更好: 更小的数据类型通常更快，因为他们占用更少的磁盘，内存和CPU缓存，并且处理时需要CPU的周期也更少，但是也要确保我们选择的类型能够存储我们需要的值的范围
- 简单就好：简单数据类型通常需要更少的CPU周期。比如整型就比字符串操作代价更低，因为字符集和校对规则（排序规则）使字符比较比整型更复杂。比方说`我们更改使用MYSQL内建的类型而不是字符串来存储时间和日期,我们应该使用整型存储IP地址`
- 尽量避免null：很多列的默认属性是`null`,通常情况下最好指定一个not null，除非蒸的需要存储null值。如果查询中包含可为null的列，对MYSQL来说更难优化，因为可为null的类使得索引和索引统计还有值比较都更加复杂。这些列也会使用更多的存储空间，在mysql里面也需要特殊处理，当这些列被索引时，每个索引记录要一个额外的字节，所以如果`计划在列上键索引就应该避免设计成null的值`

接下来是选择具体类型，很多MYSQL的数据类型可以存储相同类型的数据，只是存储的疮毒不一样，允许的精度不同，或者需要的屋里空间不同，例如DATETIME和TIMESAMP都是合一存储相同类型的数据，时间和日期，精确到秒，然而TIMESTAMP只是用DATETIME一般的空间并且会根据市区变化，具有自动更行的能力，礼仪方面，TIMESTAMP允许的返回也会小得多（datetime类型取值范围：1000-01-01 00:00:00 到 9999-12-31 23:59:59。timestamp类型取值范围：1970-01-01 00:00:00 到 2037-12-31 23:59:59）
### 1.1.1. 整数类型
- 整数类型有这样几种（tinyint smallint mediumint int bigint）分别存储8,16.24.32.64位存储空间。
- 整数类型有可选的UNSIGNED属性，表示不允许位负值，这大致可以使整数的上限提高一倍

MYSQL可以为整数类型指定宽度，例如INT(11)但是大多数情况下这是没有意义的，对于存储和计算来说，int(1)和int(20) 是相同的
### 1.1.2. 实数类型
- float 和double 类型支持使用标准的浮点运算进行近似计算
- decimal 类型用于存储精确的小数，它可以指定小数点前后所允许的最大位数，当然这也会影响列的空间消耗。mysql 中可以允许decimal 类型存储65个数字。存储方式是将数字打包保存到一个二进制字符串中（每4个字节保存9个数字）例如，  `decimal(18,9)小数点两边将各存储9个数字，一同使用9个字节：小数点钱的数字用4个字节，小数点后面的数字用4个字节，小数点本身占用一个字节`
- 浮点类型的时候通常会比Decimal使用更少的空间，所以如果不是对数字的精确度有很高的要求，那么是没有必要使用decimal

### 1.1.3. 字符串类型
**varchar 和char**
存储迎请存储这两种数据类型的方式在内存中和在磁盘中是可能不一样，所以MYSQL服务器从存储引擎读出的值可能需要转换为另一种存储格式
- varchar

    用于存储可变长度的字符串，因为它仅仅使用必要的空间。varchar 需要使用1或者2个额外字节来记录字符串的长度。    
    varchar节省了存储空间，所以对性能也有帮助，但是由于行是变长的，在update的可能使行变得比原来更长，这就导致了额外的工作，    
    一下这几种情况使用varchar更合适，字符串列的最大长度比平均长度大的多；列的更新很少，所以碎片不是问题，使用了utf-8这种复杂的字符集，等等
- char

    char类型是定长的，mysql总是根据定义的字符串长度分配足够的空间，char更合适存储很短的字符串，或者所有值都接近统一长度，或者经常变更的数据(varchar会产生一些碎片，而char不会)
> varchar(5)和varchar(200)存储 'hello'的空间开销是一样的，那么使用更短的列有什么优势呢?事实证明有很大的优势，更长的列会消耗更多的内存，因为MYSQL通常会分配固定大小的内存块来保存内部值，尤其是是用来内存临时表进行排序或者操作时，会特别糟糕，所以最好的策略是只分配真正需要的空间
### 1.1.4. BLOB和TEXT类型
blob 和text都是为了存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储    
与其它类型不同，mysql把每个blob和text值当做是一个独立的对象处理，存储引擎在存储时通常也会醉特殊的处理，当blob和text值太大时，innodb会使用专门的外部存储区域来进行存储，此时每个值在行内需要1-4个字节存储一个指针。然后再外部存储区域存储实际的值
### 1.1.5. 使用枚举代替字符串类型
有时候可以使用枚举列代替常用的字符串类型，枚举列可以吧一些不重复的字符串存储成一个预定义的集合。mysql在存储枚举时特别的经凑，会根据列表值的数量压缩到一个或者两个字节中，mysql在内部会将每个值在列表中的位置保存为整数，并且在表的.frm文件中保存“数字-字符串”映射关系的查找表，    
`当然枚举最不好的地方在于，字符串列表是固定的，添加或者删除字符串必须使用 alter table`所以对于一系列未来会改变的字符使用枚举就不是一个好主意
### 1.1.6. 日期和时间类型
**datetime**    
这个类型保存大范围值，从1001年到9999年精度为妙，它把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中，与失去无关，使用八个字节的存储空间    
**timestamp**    
timestamp保存了从1970年1月1日午夜（格林尼治标准时间）以来的微妙，他和UNIX实践出相同，timestamp只使用了4个字节存储空间，因此它比datatime小得多，只能表示1970-2038年。所以目前而言还是推荐使用timestamp

## 1.2. MYSQL schema 设计中的陷阱
- 太多的列    
    mysql的存储引擎api工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后再服务器层将缓冲内容解码成各个列，从航缓冲中将编码过的列转换成行数据结构的操作代价是非常高的，所以建议不要使用太多的列
- 太多的关联    
    mysql限制了每个关联操作最多只能有61张表，即使这样，解析和优化查询的代价也是非常高的，不易不建议太多物理关联，但是可以有很多逻辑关联


## 1.4. 缓存表和汇总表
### 1.4.1. 物化视图
### 1.4.2. 计数器表
## 1.5. 加快ALTER Table  操作的速度
### 1.5.1. 只修改 .frm 文件
### 1.5.2. 加快创建MYISAM索引
## 1.6. 总结
《高性能MYSQL第三版》读书笔记