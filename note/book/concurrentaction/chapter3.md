java并发编程实战第三章

volatile使用的几种情况：
1. 对变量的写入操作不依赖变量的当前值，或者你能够确保只有单个线程变更变量的值
2. 该变量不会与其他状态变量一起纳入不变性条件中
在访问变量是不需要加锁

安全对象构建的过程
1.不要在狗仔的过程中使用`this`引用溢出
    具体来说只有当构造函数返回时，`this`引用才应该从县城中逸出。构造函数可以将this引用保存到某个地方，只要其他线程
    不会在构造函数完成之前使用它，也就是说在在构造的构成中可以创建一个新的线程，但是最好不要立即
    弃用它，而是使用类似start或者initialize的方法来启动(这种思路有助于我们理解服务的生命周期)，
    
    
线程封闭：
    1.当访问共享的`可变数据`时，通常需要使用`同步`，一种避免使用同步的方式就是不共享数据，这种方式称之为`线程封闭`（Thread confinement）
    当某个对象封闭在某个线程中时，这种用法将自动实现线程安全。这种技术常见的应用是JDBC中的 `Connection`  
    
    当决定使用线程封闭技术的时候，通常是因为要将某个特定的子系统时限为一个单线程子系统

    volatile变量中存在一种特殊的线程封闭。只要你能确保只有单个线程对共享的volatile变凉执行写入操作，那么就可以安全第一在这些贡献的volatile变量上执行
    “读取-修改-写入”操作，这种方式相当于将修改操作粉笔在单个线程中以防止发生竞态条件，并且volatile变脸的可见性还确保了其他线程能够看到罪行的值
    问题？？？如何确保只能某个线程对volatile变量进行修改呢？？ 

经常的我们设计模式中有一个单例模式，但是在并发编程中有一个不可变对象.这两者之间有何种联系？
不可变对象（Immutable Object）
当满足一下情况时，对象才是不可变的
    1. 对象创建以后状态就不能修改(这个地方的状态描述的是什么？)
    2. 对象的所有与都是final类型
    3. 对象是正确创建的，(在对象创建期间，this引用没有逸出)
 需要注意一点的是，“不可变对象”与“不可变对线之间”还是存在着差异的，保存在不可变兑现中的状态任然是可以更新
 一般的，除非某个与是可变的，否则将其声明为final域是一个非常好的变成习惯
 
 对于在访问和更新多个相关变量是出现的竞态条件问题，可以通过将这些变量全部保存在一个不可变对象中来消除。但是如果是一个
 可变对象的化，那么就需要使用锁的方式来消除了
 
   即使某个对象的引用对其他线程是可见的，也不意味着对象状态对于使用该对象的线程来说一定是可见的，为了确保对象状态能够呈现出一支的视图
   必修使用同步
   
   任何线程都可以在不需要额外同步的情况下安全的访问不可变对象，即使在发布这些对象时没有使用同步
   
 安全发布对象的常用模式:
    要安全的发布一个独享，对象的引用以及对象的状态必须同时对其他线程可见，可通过以下几种方式安全发布
    1.在静态初始化函数中初始化一个对象的引用
    2.将对象的引用保存到volatile类型的域或者AtomicReferance对象中
    3.将对象的引用宝尊到某个正确构建对象的final类型域中
    4.将对象的引用保存在一个由锁保护的域中
    
 如果一个对象从技术上来看是不可变的，但是其状态在发布后不会在改变，那么把这种对象称之为“事实不可变对象（Effectively Immutable Object）”   

线程封闭，只读共享，线程安全共享，保护对象这些都是在并发程序中使用和共享对象时的一些策略    